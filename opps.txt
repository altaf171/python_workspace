
ðŸ‘»ðŸ‘» access instance static_variable
ðŸ¤ðŸ¤ within class by using self
ðŸ¤ðŸ¤ outside of the class with obj reference


ðŸ˜’ðŸ˜’ Type of methods in class 
(â“¿_â“¿) Instance Method 
(â“¿_â“¿) Static Method
(â“¿_â“¿) class Method


ðŸ¤ðŸ£ Instance Method 
ðŸ¦¾ first arg to self // any name we can use insteed of self
ðŸ¦¾ not need for decorator
ðŸ¦¾ access instance method
ðŸ¦¾ inside class with self
ðŸ¦¾ outside of class with object reference


ðŸ¤ðŸ£ Class Method 
ðŸ¦¾ for every class pvm will create object to hold class level data
ðŸ¦¾ cls is pointer to that class
ðŸ¦¾ syntax:
ðŸ¦¾ @classmethod
ðŸ¦¾ def methodName(cls):
ðŸ¦¾              print(cls.static_variable)
ðŸª¶ access to class method
ðŸª¶ classname.classmethod


ðŸ¤ðŸ£ Static Method 
ðŸ¦¾ syntax:
ðŸ¦¾ first arg to class method cls // any name we can use insteed of cls
ðŸ¦¾ @staticmethod
ðŸ¦¾ def methodName(a,b,c):
ðŸ¦¾         return a+b+c
ðŸª¶ access to static method
ðŸª¶ classname.classmethod
ðŸª¶or you can use instance object reference


ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜Š Self ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜Š

ðŸª¶ self is not a keyboard in python 
ðŸª¶ In class constructor and instance method first argument should be self
ðŸª¶ we can use any name insteed of self
ðŸª¶ pvm will provide value for self
ðŸª¶ we can use self only in class constructor and instance methods
ðŸª¶ in other languages self is not compelsery


ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜Š Static variable ðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜ŠðŸ˜Š
 id value of the variable is not varied from object to object 
 we should use static variable
 declaration within class directly we can declare
 by using class name we access

 various palces to declare static variable
    we can declare any where in class
    In general we declare static variable directly inside class outside of any methods
    inside constructor or instance method we can declare static variable by using class name classname.variablename = value
    inside class method by usinf class name or cls variable
    inside static method by using class name
    from outside of class, by using class name


ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ Getter and setters ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬ðŸ¤¬
ðŸª¶ðŸª¶ Getters and are setters are more sequre than constructor
def setName(self,name):
   self.name= name

def getName(self):
   return self.name

ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´ðŸ˜´
ðŸŽˆðŸŽˆðŸŽˆâœ¨ if we are using any instance better to go for instance method


ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ static method without decorator ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£
ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘» if we are using method without decorator it can act as instance or static method depending on acces method
ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘» classname.methodname it will act as static method 
ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘»ðŸ‘» objRef.methodname it will act as instance method


âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½ passing one class members ton another class âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš½


âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½ Inner classes class inside  another class âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
ðŸ€ðŸðŸ¥ŽðŸ‘»âš¾ class can have :
âš¾âš¾âš¾      instance/static/local variables
âš¾âš¾âš¾      instance/static/local variables
âš¾âš¾âš¾      obj of one class in other class obj or in class
âš¾âš¾âš¾      class inside class
      âœ¨âœ¨âœ¨âœ¨ withot existing one type of obj, there is no chance existing another type of object ,such type of cases inner classes
      âœ¨ without existing one university object there is no chance of existing department object
      âœ¨ university is outer class
      âœ¨ department is inner class

      âœ¨ class Head:
            ..
            ..
            class Brain:
               pass
            class Mouth:
               ...
            
            class Eye:
               ....

            Class Ear:
               ...

      âœ¨ inner class obj is always associate with outer class object
      ðŸ¥ŽðŸðŸ¥ŽðŸ¥ŽðŸ Nested Inner class is possible  ðŸ ðŸ¥Ž 

      âœ¨ advantages:
            1. Modularity of application will be improved 
            2. Security
            3. 





         âœ¨ class Outer:
               def __init__(self):
                  print("Outer class object craetion")
               
               class Inner:
                  def __init__(self):
                     print('Inner class object creation')
                  def m1(self):
                     print('inner class object')

                  class InnerInner:
                     def __init__(self):
                     print('InnerInner class object creation')

               class Inner2:
                   def __init__(self):
                     print('Inner2 class object creation')
                  def m1(self):
                     print('inner2 class object')

         O = outer()    ----------\
                                    or  i = Outer().Inner() 
         i = o.inner()  ----------/
         i.m1()
         
          or 
         
         Outer().Inner().m1()



         i2 = o.inner2()

         âœ¨ by using o we can call any outer class method
         âœ¨ by using we can call any inner class Method

      âœ¨âœ¨âœ¨âœ¨ class Human:
                     def __init__(self, name):
                        print('Human obj creation')
                        self.name = name
                        self.head = self.Head() # head object automatically created

                     def info(self):
                        print('Hello, My self', self.name)
                        print('im fully busy with')
                        self.head.talk()
                        self.head.brain.think()

                     class Head:
                        def __init__(self):
                           print('Head object creation')
                           self.brain = self.Brain()

                        def talk(self):
                           print('human can talk')

                        class Brain:
                           def __init__(self):
                              print('Brain object creation')
                           
                           def think(self):
                              print('human is thinking')

            
            human = Human('Durga Sir')
            human.info()

          âœ¨âœ¨âœ¨ âœ¨ class Person:
                           def __init__(self,name, dd, mm, yyyy):
                              print('Person object creation ') 
                           
                           self.nane = name
                           self.dob = self.Dob(dd,mm,yyyy)

                           def info(self):
                              print('name:' self.name)
                              self.dob.display()

                           class Dob:
                              def __init__(self, dd,mm,yyyy):
                                 print('Dob obj craetion')

                                 self.dd = dd
                                 self.mm = mm
                                 self.yyyy = yyyy

                              def display(self):
                                 print(f'Dob = {self.dd}/{self.mm}/{self.yyyy}')
                     
                     person = Person('Durga',21,3,1947)
                     person.inf()
                     person.dob.display()

âš¾ðŸðŸ¥ŽðŸ€âš½ Nested method ðŸâš¾ðŸ¥ŽðŸ€âš½
ðŸ¥Žâš¾ðŸ Inside many languages method inside method is not possible but in python it is allowed

âš½âš½ if some is required repeatedly inside method then we can use this feature of python

âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½                          âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥Ž ðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½    Garbage Collector     âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥Ž ðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½                          âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥Ž ðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ if an object not hving the reference variable  than the object will be eligible for Garbage Collector
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ how ton enable and or disable garbage collector (by default it is enabled)
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ gc Module
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ gc.isenabled() ---> return True if enabled
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ gc.disable() --->  to disable garbage collector
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ distructor --->    __del__(self)
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ just before destroying of the object, gc will execute this method , to automatically perform clean up/ resource deallocation
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ obj = None   ---> will set reference to None object 
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ del obj    ---> remove this reference to the object 
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ If object has atleast on object reference than it will not b eligible for gc
âš½âš¾ðŸ¥ŽðŸ€ðŸ‘»ðŸðŸ¥ŽðŸ sys.getrefcount(obj) ----> count reference of the object

âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½ðŸ¥ŽðŸ€ðŸ€ðŸ€ðŸ€
âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ðŸ¥ŽðŸ¥Ž oop part 2 âš½âš½âš½âš¾âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸðŸðŸ€ðŸ€ðŸ¥ŽðŸ¥Žâš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ðŸ¥ŽðŸ¥ŽðŸ€ðŸ€ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€âš½âš½âš¾ðŸ‘»ðŸ‘»ðŸ‘»ðŸðŸðŸ¥ŽðŸðŸ€ðŸ€
âœ¨âœ¨âœ¨ use members of one class in another class 
âœ¨âœ¨âœ¨ 2 ways
      âœ¨âœ¨âœ¨ 1. Composition  (Has-A-Relation)
                  class Car has a Engine reference
      âœ¨âœ¨âœ¨ 2. Inheritance Is-A relationship


ðŸ‘»ðŸ‘» class Engine:
         def  __init__(self):
            self.power = '12hp'

         def useEngine(self):
            print('Engine speific functionality')

      class Car:
         def __init__(self):
            self.engine = Engine()

         def usecar(self):
            print('car speific functionality')
            self.engine.useEngine()
            print(self.engine.power)



ðŸ‘»ðŸ‘»ðŸ‘» class Car: 
            def __init__(self, name, model, color):
               self.name= name
               self.model = model
               self.color = color
            
            def getInfo(self):
               print(f'name: {self.name}, Model : {self.model}, color : {self.color} ')

         class Employee:
            def __init__(self,name, eno, car):
               self.name = name
               self .eno = eno 
               self.car = car

            def getInfo(self):
               print(f'name:{self.name}')
               print(f'E No :{self.eno}')
               self.car.getInfo()

ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ IS-A relationship ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£ðŸ£
ðŸ£ class P:
      def m1(self):
         print('m1 method')

   class C(P):
      def m2(self):
         print('m2 Method')

   
   cobj= C()
   cobj.m1()
   cobj.m2()


ðŸ£ class P:
      # 10 methods
   
   class C(P):
      # 5 method


   p = P() # p will have 10 methods
   c= C() # c will have 15 method to access   


ðŸ£ class P:
     def __init__(self):
         print('constructor')
      def m1(self):
         print('Instance method')

      @staticmethod
      def m2():
         print('static method')

      @classmethod
      def m3(cls):


ðŸ£ðŸ£ðŸ£â¤ï¸â¤ï¸â¤ï¸ super().__init__(name,age) --> (inside child class constructer) to execute parent class constructer



