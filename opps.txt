
ğŸ‘»ğŸ‘» access instance static_variable
ğŸ¤ğŸ¤ within class by using self
ğŸ¤ğŸ¤ outside of the class with obj reference


ğŸ˜’ğŸ˜’ Type of methods in class 
(â“¿_â“¿) Instance Method 
(â“¿_â“¿) Static Method
(â“¿_â“¿) class Method


ğŸ¤ğŸ£ Instance Method 
ğŸ¦¾ first arg to self // any name we can use insteed of self
ğŸ¦¾ not need for decorator
ğŸ¦¾ access instance method
ğŸ¦¾ inside class with self
ğŸ¦¾ outside of class with object reference


ğŸ¤ğŸ£ Class Method 
ğŸ¦¾ for every class pvm will create object to hold class level data
ğŸ¦¾ cls is pointer to that class
ğŸ¦¾ syntax:
ğŸ¦¾ @classmethod
ğŸ¦¾ def methodName(cls):
ğŸ¦¾              print(cls.static_variable)
ğŸª¶ access to class method
ğŸª¶ classname.classmethod


ğŸ¤ğŸ£ Static Method 
ğŸ¦¾ syntax:
ğŸ¦¾ first arg to class method cls // any name we can use insteed of cls
ğŸ¦¾ @staticmethod
ğŸ¦¾ def methodName(a,b,c):
ğŸ¦¾         return a+b+c
ğŸª¶ access to static method
ğŸª¶ classname.classmethod
ğŸª¶or you can use instance object reference


ğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜Š Self ğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜Š

ğŸª¶ self is not a keyboard in python 
ğŸª¶ In class constructor and instance method first argument should be self
ğŸª¶ we can use any name insteed of self
ğŸª¶ pvm will provide value for self
ğŸª¶ we can use self only in class constructor and instance methods
ğŸª¶ in other languages self is not compelsery


ğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜Š Static variable ğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜ŠğŸ˜Š
 id value of the variable is not varied from object to object 
 we should use static variable
 declaration within class directly we can declare
 by using class name we access

 various palces to declare static variable
    we can declare any where in class
    In general we declare static variable directly inside class outside of any methods
    inside constructor or instance method we can declare static variable by using class name classname.variablename = value
    inside class method by usinf class name or cls variable
    inside static method by using class name
    from outside of class, by using class name


ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ Getter and setters ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬ğŸ¤¬
ğŸª¶ğŸª¶ Getters and are setters are more sequre than constructor
def setName(self,name):
   self.name= name

def getName(self):
   return self.name

ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´
ğŸˆğŸˆğŸˆâœ¨ if we are using any instance better to go for instance method


ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ static method without decorator ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£
ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘» if we are using method without decorator it can act as instance or static method depending on acces method
ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘» classname.methodname it will act as static method 
ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘»ğŸ‘» objRef.methodname it will act as instance method


âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½ passing one class members ton another class âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš½


âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½ Inner classes class inside  another class âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
ğŸ€ğŸğŸ¥ğŸ‘»âš¾ class can have :
âš¾âš¾âš¾      instance/static/local variables
âš¾âš¾âš¾      instance/static/local variables
âš¾âš¾âš¾      obj of one class in other class obj or in class
âš¾âš¾âš¾      class inside class
      âœ¨âœ¨âœ¨âœ¨ withot existing one type of obj, there is no chance existing another type of object ,such type of cases inner classes
      âœ¨ without existing one university object there is no chance of existing department object
      âœ¨ university is outer class
      âœ¨ department is inner class

      âœ¨ class Head:
            ..
            ..
            class Brain:
               pass
            class Mouth:
               ...
            
            class Eye:
               ....

            Class Ear:
               ...

      âœ¨ inner class obj is always associate with outer class object
      ğŸ¥ğŸğŸ¥ğŸ¥ğŸ Nested Inner class is possible  ğŸ ğŸ¥ 

      âœ¨ advantages:
            1. Modularity of application will be improved 
            2. Security
            3. 





         âœ¨ class Outer:
               def __init__(self):
                  print("Outer class object craetion")
               
               class Inner:
                  def __init__(self):
                     print('Inner class object creation')
                  def m1(self):
                     print('inner class object')

                  class InnerInner:
                     def __init__(self):
                     print('InnerInner class object creation')

               class Inner2:
                   def __init__(self):
                     print('Inner2 class object creation')
                  def m1(self):
                     print('inner2 class object')

         O = outer()    ----------\
                                    or  i = Outer().Inner() 
         i = o.inner()  ----------/
         i.m1()
         
          or 
         
         Outer().Inner().m1()



         i2 = o.inner2()

         âœ¨ by using o we can call any outer class method
         âœ¨ by using we can call any inner class Method

      âœ¨âœ¨âœ¨âœ¨ class Human:
                     def __init__(self, name):
                        print('Human obj creation')
                        self.name = name
                        self.head = self.Head() # head object automatically created

                     def info(self):
                        print('Hello, My self', self.name)
                        print('im fully busy with')
                        self.head.talk()
                        self.head.brain.think()

                     class Head:
                        def __init__(self):
                           print('Head object creation')
                           self.brain = self.Brain()

                        def talk(self):
                           print('human can talk')

                        class Brain:
                           def __init__(self):
                              print('Brain object creation')
                           
                           def think(self):
                              print('human is thinking')

            
            human = Human('Durga Sir')
            human.info()

          âœ¨âœ¨âœ¨ âœ¨ class Person:
                           def __init__(self,name, dd, mm, yyyy):
                              print('Person object creation ') 
                           
                           self.nane = name
                           self.dob = self.Dob(dd,mm,yyyy)

                           def info(self):
                              print('name:' self.name)
                              self.dob.display()

                           class Dob:
                              def __init__(self, dd,mm,yyyy):
                                 print('Dob obj craetion')

                                 self.dd = dd
                                 self.mm = mm
                                 self.yyyy = yyyy

                              def display(self):
                                 print(f'Dob = {self.dd}/{self.mm}/{self.yyyy}')
                     
                     person = Person('Durga',21,3,1947)
                     person.inf()
                     person.dob.display()

âš¾ğŸğŸ¥ğŸ€âš½ Nested method ğŸâš¾ğŸ¥ğŸ€âš½
ğŸ¥âš¾ğŸ Inside many languages method inside method is not possible but in python it is allowed

âš½âš½ if some is required repeatedly inside method then we can use this feature of python

âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½                          âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½    Garbage Collector     âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½                          âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ if an object not hving the reference variable  than the object will be eligible for Garbage Collector
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ how ton enable and or disable garbage collector (by default it is enabled)
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ gc Module
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ gc.isenabled() ---> return True if enabled
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ gc.disable() --->  to disable garbage collector
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ distructor --->    __del__(self)
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ just before destroying of the object, gc will execute this method , to automatically perform clean up/ resource deallocation
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ obj = None   ---> will set reference to None object 
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ del obj    ---> remove this reference to the object 
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ If object has atleast on object reference than it will not b eligible for gc
âš½âš¾ğŸ¥ğŸ€ğŸ‘»ğŸğŸ¥ğŸ sys.getrefcount(obj) ----> count reference of the object

âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½ğŸ¥ğŸ€ğŸ€ğŸ€ğŸ€
âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ğŸ¥ğŸ¥ oop part 2 âš½âš½âš½âš¾âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸğŸğŸ€ğŸ€ğŸ¥ğŸ¥âš¾âš¾âš½âš½âš½âš½âš½âš½âš½âš¾ğŸ¥ğŸ¥ğŸ€ğŸ€ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€âš½âš½âš¾ğŸ‘»ğŸ‘»ğŸ‘»ğŸğŸğŸ¥ğŸğŸ€ğŸ€
âœ¨âœ¨âœ¨ use members of one class in another class 
âœ¨âœ¨âœ¨ 2 ways
      âœ¨âœ¨âœ¨ 1. Composition  (Has-A-Relation)
                  class Car has a Engine reference
      âœ¨âœ¨âœ¨ 2. Inheritance Is-A relationship


ğŸ‘»ğŸ‘» class Engine:
         def  __init__(self):
            self.power = '12hp'

         def useEngine(self):
            print('Engine speific functionality')

      class Car:
         def __init__(self):
            self.engine = Engine()

         def usecar(self):
            print('car speific functionality')
            self.engine.useEngine()
            print(self.engine.power)



ğŸ‘»ğŸ‘»ğŸ‘» class Car: 
            def __init__(self, name, model, color):
               self.name= name
               self.model = model
               self.color = color
            
            def getInfo(self):
               print(f'name: {self.name}, Model : {self.model}, color : {self.color} ')

         class Employee:
            def __init__(self,name, eno, car):
               self.name = name
               self .eno = eno 
               self.car = car

            def getInfo(self):
               print(f'name:{self.name}')
               print(f'E No :{self.eno}')
               self.car.getInfo()

ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ IS-A relationship ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£ğŸ£
ğŸ£ class P:
      def m1(self):
         print('m1 method')

   class C(P):
      def m2(self):
         print('m2 Method')

   
   cobj= C()
   cobj.m1()
   cobj.m2()


ğŸ£ class P:
      # 10 methods
   
   class C(P):
      # 5 method


   p = P() # p will have 10 methods
   c= C() # c will have 15 method to access   


ğŸ£ class P:
     def __init__(self):
         print('constructor')
      def m1(self):
         print('Instance method')

      @staticmethod
      def m2():
         print('static method')

      @classmethod
      def m3(cls):


ğŸ£ğŸ£ğŸ£â¤ï¸â¤ï¸â¤ï¸ super().__init__(name,age) --> (inside child class constructer) to execute parent class constructer



operater overloading ---> possible for any operater
Method overloading  -->  is not possible

ğŸš§ğŸ—ğŸš§ğŸ‘·â€â™€ï¸ğŸ‘·â€â™‚ï¸ğŸš§ constructer overloading 
   constructer overloading --> is not possible

   always going to consider latest defined constructer

   âœ¨we can do same thing with 

      constructor with default arg
         def __init__(self, x=None, y=None):
            print('No-arg  | One-arg | Two-args') 


      variable length args 
         def __init__(self, *args):
            print('the length of argument is :', len(args))

ğŸš‚ğŸš‰ğŸš‰ğŸš‚ğŸš‚ Overriding

   whatever members available in parent class ara by default available in child class

   class P:
      def property(self):
         print('Land , Cash, Gold, Power')
      def marriage(self):
         print('beautyful lady, handsome boy')

   class C(P): 
      def marriage(self):
         print('beautyful lady, handsome boy -- with my own choice')

   c = C()
   c.property()
   c.marriage()


ğŸŒŸâ­âœ¨ redefing parent  class method is class method Overriding

ğŸš§ğŸš§ constructer overloading
      class P:
         def __init__(self):
            print('parent constructer')

   class C(P): 
     def __init__(self):
            print('child constructer')




ğŸš§  class Person:
         def __init__(self,name,age):
            self.name = name
            self.age = age

         def display(self):
            print('name:',self.name)
            print('age:',self.age)

   class Child:
            def __init__(self,name,age, eno, esal):
            super.__init__(name,age)
               self.eno = eno
               self.esal = esal

            def display(self):
               super.display()
               print('emp no:',self.eno)
               print('salary:',self.esal)

               

